<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/polymer-fontawesome/polymer-fontawesome.html">
<link rel="import" href="../bower_components/sortable-table/sortable-table.html">
<script src="../lib/jsorolla/src/lib/opencga-manager.js"></script>
<link rel="import" href="../lib/jsorolla/src/lib/components/opencga/jso-header.html">
<link rel="import" href="../lib/jsorolla/src/lib/components/opencga/jso-footer.html">
<link rel="import" href="../lib/jsorolla/src/lib/components/jso-window.html">
<link rel="import" href="../lib/jsorolla/src/network-viewer/jso-network-viewer.html">
<link rel="import" href="potyvirus-home.html">
<link rel="import" href="potyvirus-menu.html">

<link rel="import" href="components/pty-toolbar.html">
<link rel="import" href="components/pty-header.html">
<link rel="import" href="components/pty-3d-toolbar.html">
<link rel="import" href="components/potyvirus-interactions-table.html">

<script src="../lib/jsorolla/src/network-viewer-webgl/network-viewer-webgl.js"></script>


<polymer-element name="potyvirus-element">
    <template>
        <link rel="stylesheet" href="../lib/jsorolla/src/lib/components/jso-style.css">
        <link rel="stylesheet" href="../lib/jsorolla/src/lib/components/jso-panel.css">
        <link rel="stylesheet" href="../lib/jsorolla/src/lib/components/jso-dropdown.css">
        <link rel="stylesheet" href="../lib/jsorolla/src/lib/components/jso-form.css">
        <style>
            :host {
                display: block;
                position: relative;
                /*background-color: #314559;*/

                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                cursor: default;

                font-size: 13px;
            }

            .content {
                background-color: #435f7a;
                position: relative;
                /*min-height: calc(100vh - 160px);*/
            }

            .content > * {
                min-height: calc(100vh - 110px);
            }

            /*potyvirus-interactions-table {*/
            /*height: calc(100vh - 60px);*/
            /*}*/
            jso-network-viewer, #nvwebgl {
                height: calc(100vh - 110px);
            }

            #stats {
                background-color: #FFFFFF;
                text-align: center;
                border-top: 1px solid #d3d3d3;
                padding-top: 20px;
            }

            .infoshown {
                visibility: visible !important;
                opacity: 1 !important;
            }

            #info {
                position: fixed;
                top: 70px;
                left: 153px;
                padding: 7px;
                background-color: #fff;
                box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.2);
                /*transition: all 0.15s;*/
                visibility: hidden;
                opacity: 0;
                color: #666;
                min-height: inherit;
            }

            #menu3d {
                margin: 10px;
                position: fixed;
                top: 60px;
                left: 0px;
                min-height: inherit !important;
            }

            #menu3dnodeinfo {
                margin: 10px;
                position: fixed;
                top: 60px;
                right: 0px;
                min-height: inherit !important;
            }

            jso-footer {
                height: 50px;
            }

            table {
                border-collapse: collapse;
            }

            table, th, td {
                border: 1px solid lightgrey;
            }

            td, th {
                padding: 2px 4px;
                text-align: center;
            }

            th {
                background-color: #f0f0f0;
            }
        </style>
        <jso-header selectedOption="{{selectedOption}}"
                    userData="{{userData}}"
                    showMenu="true"
                    allowLogin="false">
            <div class="title">Potyvirus</div>
            <potyvirus-menu class="menu" selectedOption="{{selectedOption}}">
            </potyvirus-menu>
        </jso-header>

        <div class="content">

            <template if="{{selectedOption == 'home' }}">
                <potyvirus-home></potyvirus-home>
            </template>

            <template if="{{selectedOption == 'stats' }}">
                <div id="stats">
                    <pty-heatmap steps="{{heatmapSteps}}"></pty-heatmap>
                    <pty-simpson-index data="{{hcproSimpsonIndexData}}"></pty-simpson-index>
                    <pty-4a data="{{chartDegreeData}}"></pty-4a>
                    <pty-4b data="{{neighborhoodConnectivityDistributionData}}"></pty-4b>
                    <pty-4c data="{{topologicalData}}"></pty-4c>
                    <pty-4d data="{{topologicalRelatedDegreeData}}"></pty-4d>
                    <pty-4e data="{{degreeProbability}}"></pty-4e>
                    <pty-4f data="{{topologicalProbability}}"></pty-4f>
                </div>
            </template>

            <potyvirus-interactions-table interactions="{{interactions}}" datasym="{{datasym}}" rcThreshold="{{rcThreshold}}"
                                          hidden?="{{selectedOption != 'interactions'}}"></potyvirus-interactions-table>
            <jso-network-viewer lite="false" id="networkViewer" hidden?="{{selectedOption != 'vhpi'}}"></jso-network-viewer>

            <div class="panel panel-shadow" id="menu3d" hidden?="{{selectedOption != 'vhpi3d'}}">
                <div class="header" horizontal layout>
                    <div class="text">Options</div>
                </div>
                <div class="container" style="padding:10px;">
                    <!--<div class="button action" on-click="{{handleShowCommunities}}">Show communities</div>-->
                    <!--<div class="button action" on-click="{{handleHideCommunities}}">Hide communities</div>-->
                    <div class="button action" on-click="{{handleHideEdges}}">Hide edges</div>
                    <div class="button action" on-click="{{handleShowEdges}}">Show edges</div>
                    <div style="margin-top: 20px;" class="button action" on-click="{{handle3dLayout}}" data-v="force">Force layout</div>
                    <div class="button action" on-click="{{handle3dLayout}}" data-v="circle">Circle layout</div>
                    <div style="margin-top: 20px;">
                        <!--<div class="button action" on-click="{{handleProteinMenu}}" data-protein="all">All</div>-->
                        <template repeat="{{b in  potyvirusProteinNameList}}">
                            <div class="button action" on-click="{{handleProteinMenu}}" data-checked="{{currentProtein == b}}" data-protein="{{b}}">{{b}}</div>
                        </template>
                    </div>
                </div>
            </div>
            <div class="panel panel-shadow" id="menu3dnodeinfo" hidden?="{{selectedOption != 'vhpi3d'}}">
                <div class="header" horizontal layout>
                    <div class="text">Node information</div>
                </div>
                <div class="container" style="padding:10px;" hidden?="{{vertexinfo == null}}">
                    {{vertexinfo.type}}<br>
                    Name: <b>{{vertexinfo.vertex.id}}</b><br>
                    Level: <b>{{vertexinfo.level}}</b><br>
                    Position: <b>{{vertexinfo.x}}, {{vertexinfo.y}}, {{vertexinfo.z}}</b><br>
                    <template if="{{vertexinfo.type == 'Virus protein'}}">
                        <br>
                        <table style="width:150px;">
                            <caption>Effect propagation count</caption>
                            <tr>
                                <th>Level</th>
                                <th>Count</th>
                            </tr>
                            <template repeat="{{item in vertexinfo.propagation}}">
                                <tr>
                                    <td>{{item.level}}</td>
                                    <td>{{item.count}}</td>
                                </tr>
                            </template>
                        </table>
                    </template>

                </div>
            </div>
            <div id="nvwebgl" hidden?="{{selectedOption != 'vhpi3d'}}" style="background-color:#333">
            </div>

            <div id="info" hidden?="{{selectedOption != 'vhpi3d'}}">{{message}}</div>
        </div>
        <jso-footer>
            Potyvirus -
            Universitat Polit√®cnica de Valencia, Valencia, Spain -
            Principe Felipe Research Center, Valencia, Spain -
            2015
        </jso-footer>
    </template>
    <script>
        Polymer({
            created: function () {
                this.interactions = [];
                this.datasym = [];
                this.userData;
                this.allOrdered = ["P1", "HC-Pro", "P3", "6K1", "CI", "6K2", "VPg", "NIa-Pro", "NIb", "CP", "P3N-PIPO"];
                this.potyvirusProteinNameList = [];

                this.message = "";

                this.rcThreshold = 44;

                this.layout = 'force'

                /* stats */
                this.chartDegreeData = {}
                this.heatmapSteps;
                this.hcproSimpsonIndexData;
                this.neighborhoodConnectivityDistributionData;
            },
            selectedOptionChanged: function () {
                var me = this;
                setTimeout(function () {
//                    me.$.networkViewer.zoom = 20;
                    me.$.networkViewer.setLayout('Circle');
                }, 300);
            },
            handle3dLayout: function (e) {
                this.showInfo("Loading...");
                this.layout = e.currentTarget.dataset.v;
                this._processLayout();
            },
            handleShowEdges: function (e) {
                this.hideEdges = false;
                this.showInfo("Loading...");
                this._processLayout();
            },
            handleHideEdges: function (e) {
                this.hideEdges = true;
                this.showInfo("Loading...");
                this._processLayout();
            },
            handleShowCommunities: function (e) {
                this.showCommunities = true;
                this.showInfo("Loading...");
                this._processLayout();
            },
            handleHideCommunities: function (e) {
                this.showCommunities = false;
                this.showInfo("Loading...");
                this._processLayout();
            },
            handleProteinMenu: function (e) {
                this.showInfo("Loading...");
                this.currentProtein = e.currentTarget.dataset.protein;
                this._processLayout();
            },
            showInfo: function (msg) {
                if (msg == false) {
                    this.message = "";
                    this.$.info.classList.remove('infoshown');
                } else {
                    this.message = msg;
                    this.$.info.classList.add('infoshown');
                }
            },
            ready: function () {
                this.selectedOption = 'vhpi3d';
                this.$.networkViewer.selectedMenu = '';

                this.$.networkViewer.$.nodeRender.setAttribute('hidden', '');
                this.$.networkViewer.$.edgeRender.setAttribute('hidden', '');
            },
            domReady: function () {
                var me = this;
//                this.getInteractionsSif();

                this.getInteractions();

                var height = window.innerHeight - 65;
                var width = window.innerWidth;
                this.networkViewerWebgl = new NetworkViewerWebgl({
                    target: this.$.nvwebgl,
                    width: width,
                    height: height,
                    handlers: {
                        vertexhover: function (e) {
                            var vertex = e.vertex;
                            var type = 'Plant protein';
                            if (me.potyvirusPorteinNames[vertex.id] != null) {
                                type = 'Virus protein';
//                                var simpson = [];
//                                for (var key in me.processed) {
//                                    if (key.indexOf(vertex.id) == 0 && key != (vertex.id + "_" + vertex.id)) {
//                                        simpson.push({
//                                            protein: key.split("_")[1],
//                                            values: me.processed[key]
//                                        })
//                                    }
//                                }
                            }
                            me.vertexinfo = {
                                vertex: vertex,
                                level: me.levelResults[me.currentProtein].all[vertex.id] || 13,
                                x: parseInt(vertex.position.x),
                                y: parseInt(vertex.position.y),
                                z: parseInt(vertex.position.z),
                                type: type,
                                propagation: me.levelResults[me.currentProtein].levelCount
//                                simpson: simpson
                            };

                        }
                    }
                });

                var me = this;
                setTimeout(function () {
//                    me.getPlantInteractome();
                }, 100);
            },
            rcThresholdChanged: function () {
                this.updateNetworkViewerGraph();
            },
            getInteractions: function () {
                var me = this;

                var undirectedMap = {};
                var interactions = [];
                var responseCount = 0;

                var request = new XMLHttpRequest();
                request.onload = function () {
                    var response = this.response;

                    responseCount++;
                    var lines = response.split('\n');
                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i];
                        if (line.trim().length != 0) {
                            var fields = line.split('\t');
                            var key1 = fields[0] + fields[1] + fields[3];
                            var key2 = fields[1] + fields[0] + fields[3];
                            if (undirectedMap[key1] != true && undirectedMap[key2] != true) {
                                var obj = {
                                    p1: fields[0],
                                    p2: fields[1],
                                    reference: fields[2],
                                    species: fields[3],
                                    detection: fields[4],
                                    intesity: fields[5],
                                    detected: fields[6],
                                    tested: fields[7]
                                };
//                                if (obj.p1 == 'P1' && obj.p2 == 'HCPro') {
                                interactions.push(obj);
                                undirectedMap[key1] = true;
                                undirectedMap[key2] = true;
//                                }

                            }

                        }
                    }
                    me.interactions = interactions;
                    me.processDataSym();

                };
                request.onerror = function () {
                    console.log('error loading file');
                };
                request.open('GET', 'files/interactions.tsv', true);
                request.send();
            },
            processDataSym: function () {
//                                              BiFC	            Y2H		            Total
//                Protein A	Protein B	Detected	Tested	Detected	Tested	Detected	Tested	RC
                var map = {};
                var datasym = [];
                for (var i = 0; i < this.interactions.length; i++) {
                    var interaction = this.interactions[i];
                    var key1 = interaction.p1 + ">" + interaction.p2;
                    var key2 = interaction.p2 + "<" + interaction.p1;
                    if (map[key1] == null && map[key2] == null) {
                        var obj = {
                            p1: interaction.p1,
                            p2: interaction.p2,
                            detectedbifc: 0,
                            testedbifc: 0,
                            detectedy2h: 0,
                            testedy2h: 0,
                            detectedtotal: 0,
                            testedtotal: 0,
                            rc: 0
                        }
                        map[key1] = obj;
                        map[key2] = true;
                        datasym.push(obj);
                    }
                    var obj = map[key1];
                    var d = (parseInt(interaction.detected) > 0) ? 1 : 0;
                    var t = (parseInt(interaction.tested) > 0) ? 1 : 0;
                    if (interaction.detection == 'BiFC') {
                        obj.detectedbifc += d;
                        obj.testedbifc += t;
                    } else if (interaction.detection == 'Y2H') {
                        obj.detectedy2h += d;
                        obj.testedy2h += t;
                    }
                    obj.detectedtotal += d;
                    obj.testedtotal += t;


                }
                for (var i = 0; i < datasym.length; i++) {
                    var symi = datasym[i];
                    symi.rc = ((2 / (symi.testedtotal + 1)) * symi.detectedbifc) + ((1 / (symi.testedtotal + 1)) * symi.detectedy2h);
                    symi.rc = Math.round(symi.rc * 100);
                }

                this.datasym = datasym;

                this.updateNetworkViewerGraph();
            },
            updateNetworkViewerGraph: function () {
                var me = this;

                //Update network viewer virus graph
                this.$.networkViewer.startOver();
                //set rc attribute
                this.$.networkViewer.eAttr.addColumn({
                    defaultValue: "",
                    name: "rc",
                    title: "Relevance coefficient",
                    type: "string",
                    cellTemplate: "inputTemplate"
                });
                for (var i = 0; i < this.datasym.length; i++) {
                    var obj = this.datasym[i];
                    if (obj.rc >= this.rcThreshold) {
                        var sourceVertex = this.$.networkViewer.createVertex(0, 0, obj.p1);
                        var targetVertex = this.$.networkViewer.createVertex(0, 0, obj.p2);

                        var e = this.$.networkViewer.createEdge(sourceVertex, targetVertex, 'link');
                        this.$.networkViewer.eAttr.getRow(e.id)['rc'] = obj.rc;
                    }
                }


                //Claculate neighbours
                this.neighborsArraysMap = {};
                this.neighborsMapsMap = {};
                for (var i = 0; i < this.$.networkViewer.graph.vertices.length; i++) {
                    var vertex = this.$.networkViewer.graph.vertices[i];
                    //find neighbors
                    var neighborsMap = {};
                    var neighborsArray = [];
                    for (var j = 0; j < vertex.edges.length; j++) {
                        var edge = vertex.edges[j];
                        if (edge.source != vertex && neighborsMap[edge.source.id] == null) {
                            neighborsMap[edge.source.id] = edge.source;
                            neighborsArray.push(edge.source);
                        } else if (edge.target != vertex && neighborsMap[edge.target.id] == null) {
                            neighborsMap[edge.target.id] = edge.target;
                            neighborsArray.push(edge.target);
                        }
                    }
                    this.neighborsArraysMap[vertex.id] = neighborsArray;
                    this.neighborsMapsMap[vertex.id] = neighborsMap;
                }


                //VIRUS PROTEINS
                this.potyvirusProteinNameList = [];
                this.potyvirusPorteinNames = {};
                for (var i = 0; i < this.$.networkViewer.graph.vertices.length; i++) {
                    var vertex = this.$.networkViewer.graph.vertices[i];
                    this.potyvirusPorteinNames[vertex.id] = true;
                }

                for (var i = 0; i < this.allOrdered.length; i++) {
                    var pname = this.allOrdered[i];
                    if (pname in this.potyvirusPorteinNames) {
                        this.potyvirusProteinNameList.push(pname);
                    }
                }


                //STATS Degree - Call topological analysis
                this.$.networkViewer.$.topologicalStudy.retrieveData(function () {

                    /* fix clustering coefficient */
                    me._clusteringCoefficient();
                    /*add neighborhood Connectivity*/
                    me._neighborhoodConnectivity();
                    /*add topological coefficient*/
                    me._topologicalCoefficient();

                    var degree = [];
                    var clustering = [];
                    var topological = [];
                    var closeness = [];
                    var betweeness = [];
                    var categories = [];
                    var neighborhoodConnectivityDistributionData = [];
                    var clusteringDegree = [];
                    var topologicalDegree = [];
                    var closenessDegree = [];
                    var betweenessDegree = [];

                    var data = me.$.networkViewer.vAttr.data;
                    for (var i = 0; i < data.length; i++) {
                        var n = data[i];

                        /*  FIX betweenness */
                        n.betweenness = parseFloat(n.betweenness) / 45;

                        /*  FIX closenessCentrality */
                        n.closenessCentrality = parseFloat(n.closenessCentrality) * 10;

                        categories.push(n.id);
                        degree.push(parseInt(n.degree));
                        clustering.push(parseFloat(n.clusteringCoefficient));
                        topological.push(parseFloat(n.topologicalCoefficient));
                        closeness.push(parseFloat(n.closenessCentrality));
                        betweeness.push(parseFloat(n.betweenness));
                        neighborhoodConnectivityDistributionData.push({
                            x: me.neighborsArraysMap[n.id].length,
                            y: n.neighborhoodConnectivity
                        });
                        clusteringDegree.push({x: parseInt(n.degree), y: parseFloat(n.clusteringCoefficient)});
                        topologicalDegree.push({x: parseInt(n.degree), y: parseFloat(n.topologicalCoefficient)});
                        closenessDegree.push({x: parseInt(n.degree), y: parseFloat(n.closenessCentrality)});
                        betweenessDegree.push({x: parseInt(n.degree), y: parseFloat(n.betweenness)});
                    }

                    me.chartDegreeData = {categories: categories, values: degree};
                    me.neighborhoodConnectivityDistributionData = neighborhoodConnectivityDistributionData;
                    me.topologicalData = {
                        categories: categories,
                        clustering: clustering,
                        topological: topological,
                        closeness: closeness,
                        betweeness: betweeness
                    };
                    me.topologicalRelatedDegreeData = {
                        clustering: clusteringDegree,
                        topological: topologicalDegree,
                        closeness: closenessDegree,
                        betweeness: betweenessDegree
                    };
                    me.degreeProbability = degree;
                    me.topologicalProbability = {
                        clustering: clustering,
                        topological: topological,
                        closeness: closeness,
                        betweeness: betweeness
                    };
                });


                this.readPlantInteractome(function () {
                    // Simpson Index processing
                    me.processed = {};
                    for (var i = 0; i < me.allOrdered.length; i++) {
                        var a = me.allOrdered[i];
                        for (var j = 0; j < me.allOrdered.length; j++) {
                            var b = me.allOrdered[j];
                            var key1 = a + '_' + b;
                            var key2 = b + '_' + a;

                            if (!(key1 in me.processed) && !(key2 in me.processed)) {
                                var res = me._calculateSimpsonIndex(a, b);
                                me.processed[key1] = res;
                                me.processed[key2] = res;
                            }

                        }
                    }


                    //STATS heatmap data
                    var heatmapData = [];
                    for (var i = 0; i < 12; i++) {
                        heatmapData.push([]);
                        for (var j = 0; j < me.allOrdered.length; j++) {
                            var a = me.allOrdered[j];
                            for (var k = 0; k < me.allOrdered.length; k++) {
                                var b = me.allOrdered[k];
                                var key = a + '_' + b;
                                heatmapData[i].push(me.processed[key][i]);
                            }
                        }
                    }
                    me.heatmapSteps = heatmapData;


                    //STATS hcpro simpson index data
                    var hcproData = {};
                    var a = "HC-Pro";
                    for (var i = 0; i < me.allOrdered.length; i++) {
                        var b = me.allOrdered[i];
                        var key = a + '_' + b;
                        hcproData[b] = me.processed[key];
                    }
                    me.hcproSimpsonIndexData = hcproData;


                    me.currentProtein = me.$.networkViewer.graph.vertices[0].id;
                    me._processLayout();


                });

            },
            _clusteringCoefficient: function () {
//                http://en.wikipedia.org/wiki/Clustering_coefficient
//                https://www.udacity.com/course/viewer#!/c-cs215/l-48311840/m-48725187
                /** Clustering coefficient for each node **/
                for (var i = 0; i < this.$.networkViewer.graph.vertices.length; i++) {
                    var vertex = this.$.networkViewer.graph.vertices[i];
                    //find neighbors
                    var neighborsMap = {};
                    var neighborsArray = [];
                    for (var j = 0; j < vertex.edges.length; j++) {
                        var edge = vertex.edges[j];
                        if (edge.source != vertex && neighborsMap[edge.source.id] == null) {
                            neighborsMap[edge.source.id] = edge.source;
                            neighborsArray.push(edge.source);
                        } else if (edge.target != vertex && neighborsMap[edge.target.id] == null) {
                            neighborsMap[edge.target.id] = edge.target;
                            neighborsArray.push(edge.target);
                        }
                    }
                    //count edges connected between neighbors
                    var edgeCount = 0;
                    for (var j = 0; j < neighborsArray.length; j++) {
                        var neighborVertex = neighborsArray[j];
                        for (var k = 0; k < neighborVertex.edges.length; k++) {
                            var neighborEdge = neighborVertex.edges[k];
                            if (
                                    neighborEdge.source.id != neighborEdge.target.id &&
                                    neighborsMap[neighborEdge.source.id] != null &&
                                    neighborsMap[neighborEdge.target.id] != null
                            ) {
                                edgeCount++;
                            }
                        }
                    }
                    edgeCount = edgeCount / 2;

                    var k = neighborsArray.length;
                    var clustering_coefficient = (2 * edgeCount) / (k * (k - 1));
                    if (isNaN(clustering_coefficient)) {
                        clustering_coefficient = 0;
                    }
                    console.log(vertex.id + " - Clustering coefficient: " + clustering_coefficient);
                    this.$.networkViewer.vAttr.getRow(vertex.id)['clusteringCoefficient'] = clustering_coefficient;
                }
            },
            _topologicalCoefficient: function () {
//                http://med.bioinf.mpi-inf.mpg.de/netanalyzer/help/2.7/#topCoefs
                /** Topological coefficient for each node **/
                this.$.networkViewer.vAttr.addColumn({
                    defaultValue: "",
                    name: "topologicalCoefficient",
                    title: "Topological coefficient",
                    type: "string",
                    cellTemplate: "inputTemplate"
                });
                var neighborsArraysMap = {};
                var neighborsMapsMap = {};
                for (var i = 0; i < this.$.networkViewer.graph.vertices.length; i++) {
                    var vertex = this.$.networkViewer.graph.vertices[i];
                    //find neighbors
                    var neighborsMap = {};
                    var neighborsArray = [];
                    for (var j = 0; j < vertex.edges.length; j++) {
                        var edge = vertex.edges[j];
                        if (edge.source != vertex && neighborsMap[edge.source.id] == null) {
                            neighborsMap[edge.source.id] = edge.source;
                            neighborsArray.push(edge.source);
                        } else if (edge.target != vertex && neighborsMap[edge.target.id] == null) {
                            neighborsMap[edge.target.id] = edge.target;
                            neighborsArray.push(edge.target);
                        }
                    }
                    neighborsArraysMap[vertex.id] = neighborsArray;
                    neighborsMapsMap[vertex.id] = neighborsMap;
                }
                for (var i = 0; i < this.$.networkViewer.graph.vertices.length; i++) {
                    var vertex_n = this.$.networkViewer.graph.vertices[i];

                    var nmSharedCountSum = 0;
                    var aux = 0;
                    for (var j = 0; j < this.$.networkViewer.graph.vertices.length; j++) {
                        var vertex_m = this.$.networkViewer.graph.vertices[j];
                        var nmSharedCount = 0;
                        var shareAtLeastOneNeighbor = false;
                        if (vertex_n != vertex_m) {
                            for (var k = 0; k < neighborsArraysMap[vertex_n.id].length; k++) {
                                var v = neighborsArraysMap[vertex_n.id][k];
                                if (v.id in neighborsMapsMap[vertex_m.id]) {
                                    nmSharedCount++;
                                    shareAtLeastOneNeighbor = true;
                                }
                            }
                            if (shareAtLeastOneNeighbor == true) {
                                if (vertex_n.id in neighborsMapsMap[vertex_m.id]) {
                                    nmSharedCount++;
                                }
                                aux++;
                            }
                        }
                        nmSharedCountSum += nmSharedCount;
                    }
                    var avg = nmSharedCountSum / aux;
                    var topologicalCoefficient = avg / neighborsArraysMap[vertex_n.id].length;
                    if (neighborsArraysMap[vertex_n.id].length <= 1) {
                        topologicalCoefficient = 0;
                    }
                    this.$.networkViewer.vAttr.getRow(vertex_n.id)['topologicalCoefficient'] = topologicalCoefficient;
                }
            },
            _neighborhoodConnectivity: function () {
                /** Neighborhood connectivity of each node **/
                this.$.networkViewer.vAttr.addColumn({
                    defaultValue: "",
                    name: "neighborhoodConnectivity",
                    title: "Neighborhood connectivity",
                    type: "string",
                    cellTemplate: "inputTemplate"
                });
                var neighbors = {};
                for (var i = 0; i < this.$.networkViewer.graph.vertices.length; i++) {
                    var vertex = this.$.networkViewer.graph.vertices[i];
                    //find neighbors
                    var neighborsMap = {};
                    var neighborsArray = [];
                    for (var j = 0; j < vertex.edges.length; j++) {
                        var edge = vertex.edges[j];
                        if (edge.source != vertex && neighborsMap[edge.source.id] == null) {
                            neighborsMap[edge.source.id] = edge.source;
                            neighborsArray.push(edge.source);
                        } else if (edge.target != vertex && neighborsMap[edge.target.id] == null) {
                            neighborsMap[edge.target.id] = edge.target;
                            neighborsArray.push(edge.target);
                        }
                    }
                    neighbors[vertex.id] = neighborsArray;
                }
                for (var i = 0; i < this.$.networkViewer.graph.vertices.length; i++) {
                    var vertex = this.$.networkViewer.graph.vertices[i];
                    var sum = 0;
                    for (var j = 0; j < neighbors[vertex.id].length; j++) {
                        var vertexNeighbor = neighbors[vertex.id][j];
                        sum += neighbors[vertexNeighbor.id].length;
                    }
                    var neighborhoodConnectivity = sum / neighbors[vertex.id].length;
                    this.$.networkViewer.vAttr.getRow(vertex.id)['neighborhoodConnectivity'] = neighborhoodConnectivity;
                }

            },
            _calculateSimpsonIndex: function (a, b) {
//                console.log("----" + a + '-' + b + '----');
                var result = [];
                var ra = this.levelResults[a];
                var rb = this.levelResults[b];
                if (ra == null || rb == null) {
                    for (var i = 1; i < 13; i++) {
                        result.push(0);
//                        console.log(i + ' - ' + 0);
                    }
                    return result;
                }


                var la_acc = 0;
                var lb_acc = 0;
                var lvla = 0;
                var lvlb = 0;
                for (var i = 1; i < 13; i++) {
                    var key, intersectionCount = 0;
                    for (var j = 1; j <= i; j++) {
                        lvla = j;
                        lvlb = j;
                        if (!ra[j]) {
                            lvla = ra.max_level;
                        }
                        if (!rb[j]) {
                            lvlb = rb.max_level;
                        }
                        for (key in ra[lvla]) {
                            if (key in rb.all && rb.all[key] <= i) {
                                intersectionCount++;
                            }
                        }
                    }

                    if (ra[i]) {
                        la_acc = la_acc + Object.keys(ra[i]).length;
                    }
                    if (rb[i]) {
                        lb_acc = lb_acc + Object.keys(rb[i]).length;
                    }

                    var v = (intersectionCount / Math.min(la_acc, lb_acc));
//                    var v_round = Math.round(v * 100) / 100;
                    var v_round = v.toFixed(2);
                    console.log(i + ' - ' + v + ' - ' + v_round + '    - ' + la_acc + ' - ' + lb_acc);

                    result.push(v_round);
                }
                return result;
            },
            handleAppMenu: function (e) {
                this.$.sidePanel.classList.toggle('side-panel-shown');
            },
            getPlantInteractome: function () {
                var me = this;
                var request = new XMLHttpRequest();
                request.onload = function () {
                    var textNetworkDataAdapter = new TextNetworkDataAdapter({
                        dataSource: new StringDataSource(this.response),
                        handlers: {
                            'data:load': function (event) {
//                        var graph = event.sender.parseColumns(0, 1, -1, 'hh');
                                var graph = event.sender.parseColumns(0, 2, 1);

//                        sphereSurface(graph.vertices, 400, 300);
//                        circleLevels(graph.vertices, 600, 300);


//                        var virusVertices = [];
//                        var plantVertices = [];
//
//                        for (var i = 0, l = graph.vertices.length; i < l; i++) {
//                            var vertex = graph.vertices[i];
//                            if (typeof vertex !== 'undefined') {
//                                if (vertex.id in potyvirusPorteinNames) {
//                                    virusVertices.push(vertex);
//                                } else {
//                                    plantVertices.push(vertex);
//                                }
//                            }
//                        }
//                            circleLevels(virusVertices, 300, 50);
//                            circleLevels(plantVertices, 500, 350);
//                            networkViewerWebgl.renderGraph(graph);

                                me.forceDirected(graph.vertices, graph.edges, function (vertices) {
                                    for (var i = 0; i < vertices.length; i++) {
                                        var v = vertices[i];
                                        var vertex = graph.getVertexById(v.id);
                                        var z = 0;
                                        if (vertex.id in me.potyvirusPorteinNames) {
                                            z = 100;
                                        } else {
                                            z = 300;
                                        }
                                        vertex.position.set(v.x, v.y, z);
                                    }
                                    me.networkViewerWebgl.renderGraph(graph);
                                });

                            },
                            'error:parse': function (event) {
                                console.log(event);
                            }
                        }
                    });

                };
                request.onerror = function () {
                    console.log('error loading file');
                };
                request.open('GET', 'files/vh0-1.sif', true);
                request.send();
            },
            readPlantInteractome: function (callback) {
                this.showInfo("Loading...");

                var me = this;
                var request = new XMLHttpRequest();
                request.onload = function () {
                    var textNetworkDataAdapter = new TextNetworkDataAdapter({
                        dataSource: new StringDataSource(this.response),
                        handlers: {
                            'data:load': function (event) {
                                var graph = event.sender.parseColumns(0, 1, -1, 'link');
                                me.graph = graph;
                                me._processPlantNetwork(graph);
                                callback();
                            },
                            'error:parse': function (event) {
                                console.log(event);
                            }
                        }
                    });

                };
                request.onerror = function () {
                    console.log('error loading file');
                };
                request.open('GET', 'files/Ath_Interactome.txt', true);
                request.send();
            },
            _processPlantNetwork: function (graph) {
                var me = this;
                var results = {};
                for (var i = 0; i < this.potyvirusProteinNameList.length; i++) {
                    var protein = this.potyvirusProteinNameList[i];
                    results[protein] = null;
                }

                var visited, protein, visited2;
                var processNode = function (origen, lvl) {
                    var destino = [];
                    for (var i = 0; i < origen.length; i++) {
                        var node = origen[i];
                        for (var j = 0, lj = node.edges.length; j < lj; j++) {
                            var edge = node.edges[j];
                            if (edge.source == node) {
                                if (visited[edge.target.id] == null /*&& me.potyvirusPorteinNames[edge.target.id] == null*/) {
                                    visited[edge.target.id] = lvl;
                                    destino.push(edge.target);


                                    if (!visited2[lvl]) {
                                        visited2[lvl] = {};
                                    }
                                    visited2[lvl][edge.target.id] = lvl;
                                }
                            }
                            else if (edge.target == node) {
                                if (visited[edge.source.id] == null && me.potyvirusPorteinNames[edge.source.id] == null) {
                                    visited[edge.source.id] = lvl;
                                    destino.push(edge.source);


                                    if (!visited2[lvl]) {
                                        visited2[lvl] = {};
                                    }
                                    visited2[lvl][edge.source.id] = lvl;
                                }
                            } else {
                                console.log("NO DEBE SALIR")
                            }
                        }
                    }
//                    console.log(lvl + ' - ' + origen.length + ' - ' + Object.keys(visited).length);
                    delete origen;
                    if (destino.length > 0) {
                        processNode(destino, lvl + 1);
                    }
                };


                for (var i = 0; i < this.potyvirusProteinNameList.length; i++) {
                    var levels = {};
                    protein = this.potyvirusProteinNameList[i];
                    console.log(protein)
                    var n = graph.getVertexById(protein);
                    visited = {};
                    visited2 = {};
                    if (n) {
                        visited[n.id] = 1;
                        visited2[1] = {};
                        visited2[1][n.id] = 1;
                        processNode([n], 1);
                        visited2['max_level'] = Object.keys(visited2).length;
                        visited2['all'] = visited;

                        var acc = 0;
                        var levelCount = [];
                        for (var j = 1; j < 13; j++) {
                            if (visited2[j]) {
                                acc = acc + Object.keys(visited2[j]).length;
                                levelCount.push({level: j, count: acc});
                            }
                        }
                        visited2['levelCount'] = levelCount;

                        results[protein] = visited2;
                    }
                }
                this.levelResults = results;


//                if (!n) {
//                    me.networkViewerWebgl.clean();
//                    me.networkViewerWebgl.renderScene();
//                    me.showInfo("Not interact");
//                    return
//                }
//                if (visited[n.id] == null) {
//                    visited[n.id] = 1;
//                }
//                processNode([n], 1);

            },
            _processLayout: function () {
                var me = this;
                var start = new Date().getTime();
                var virusNodeSize = 80;
                if (this.layout == "force") {
                    var r2 = new XMLHttpRequest();
                    r2.open('GET', 'files/force-layout.txt', false);
                    r2.send();
                    var forceLayoutVertices = JSON.parse(r2.response);
                    if (this.showCommunities != true) {
                        for (var i = 0; i < forceLayoutVertices.length; i++) {
                            var v = forceLayoutVertices[i];
                            var vertex = this.graph.getVertexById(v.id);
                            if (vertex) {
                                var lvl = this.levelResults[this.currentProtein].all[vertex.id] || 13;
                                var z = 1000 - (0 + lvl * 100);
                                vertex.position.set(v.x, v.y, z);
                                var aux = Math.round(50 + ((14 - lvl) * 10)).toString(16);
                                vertex.renderer.color = "#" + "00" + "00" + aux;
//                                console.log(vertex.renderer.color);

                                if (vertex.id in this.potyvirusPorteinNames) {
                                    vertex.renderer.size = virusNodeSize;
                                    vertex.renderer.color = "#00FF00";
                                }
                            }
                        }
                    } else {
                        this.message = "Calculating communities..."
                        var sif = this.graph.getAsSIFNoRelation();
                        var formData = new FormData();
                        formData.append("sif", sif);
                        formData.append("directed", "F");
                        formData.append("weighted", "F");
                        formData.append("method", "fastgreedy");
                        var request = new XMLHttpRequest();
                        request.onload = function () {
                            var response;
                            var contentType = this.getResponseHeader('Content-Type');
                            if (contentType === 'application/json') {
                                response = JSON.parse(this.response);
                            } else {
                                response = this.response;
                            }
                            if (response.error === "") {
                                var results = response.response[0].results;
                                var lines = response.response[0].attributes.split("\n");
                                var line, fields;
                                var row;
                                for (var i = 0; i < lines.length; i++) {
                                    line = lines[i];
                                    if (line !== "") {
                                        fields = line.split("\t");
                                        var vertex = me.graph.getVertexById(fields[0]);
                                        vertex.renderer.color = fields[2];
                                    }
                                }
                            }
                            me.message = "Done"
                        };
                        request.onerror = function () {
                            console.log("request error");
                            me.message = "Done"
                        };
                        request.open("POST", OpencgaManager.host + '/util/network/community', true);
                        request.send(formData);
                    }

//                                    me.forceDirected(graph.vertices, graph.edges, function (d3Vertices) {
//                                    var ve = [];
//                                        for (var i = 0; i < d3Vertices.length; i++) {
//                                            var v = d3Vertices[i];
//                                        ve.push({x: v.x, y: v.y, id: v.id});
//                                            var vertex = graph.getVertexById(v.id);
//                                            var lvl = visited[vertex.id] || 15;
//                                            var z = 1000 - (500 + lvl * 50);
//                                            vertex.position.set(v.x, v.y, z);
//                                        }
////
//                                        var str = JSON.stringify(ve);
//                                        var blob = new Blob([str], {type: "data:text/tsv"});
//                                        var url = URL.createObjectURL(blob);
//                                        var link = document.createElement('a');
//                                        link.href = url;
//                                        link.download = "force-layout.txt";
//                                        var event = new MouseEvent('click', {
//                                            'view': window,
//                                            'bubbles': true,
//                                            'cancelable': true
//                                        });
//                                        link.dispatchEvent(event);
//                                    });

//                    this.circleLevels(virusVertices, 200, 600);
//                    for (var i = 0; i < virusVertices.length; i++) {
//                        var v = virusVertices[i];
//                        var vertex = graph.getVertexById(v.id);
//                        vertex.position.set(v.position.x, v.position.y, v.position.z);
//                    }

                    this.networkViewerWebgl.renderGraph(this.graph, this.hideEdges);
                    var end = new Date().getTime();
                    var time = end - start;
                    this.showInfo("Done in " + (time) + " ms");
                }

                if (this.layout == "circle") {
                    var levelMap = {};
                    for (var i = 0, l = this.graph.vertices.length; i < l; i++) {
                        var vertex = this.graph.vertices[i];
                        var level = this.levelResults[this.currentProtein].all[vertex.id] || 13;
                        if (levelMap[level] == null) {
                            levelMap[level] = [];
                        }
                        levelMap[level].push(vertex);

                        if (vertex.id in this.potyvirusPorteinNames) {
                            vertex.renderer.size = virusNodeSize;
                        }
                    }
                    for (level in levelMap) {
                        var lvl = parseInt(level);
                        this.circleLevels(levelMap[level], lvl * 80, (1000 - (0 + lvl * 100)))
                    }

//                    this.circleLevels(virusVertices, 200, 600);
//                    for (var i = 0; i < virusVertices.length; i++) {
//                        var v = virusVertices[i];
//                        var vertex = graph.getVertexById(v.id);
//                        vertex.position.set(v.position.x, v.position.y, v.position.z);
//                    }

                    this.networkViewerWebgl.renderGraph(this.graph, this.hideEdges);
                    var end = new Date().getTime();
                    var time = end - start;
                    this.showInfo("Done in " + (time) + " ms");
                }

            },

            /* ** */
            /* ** */
            /* layout */
            /* ** */
            /* ** */
            circleLevels: function (vertices, radius, z) {
                var centerX = 0;
                var centerY = 0;
                var x, y;
                for (var i = 0, l = vertices.length; i < l; i++) {
                    var vertex = vertices[i];
                    if (typeof vertex !== 'undefined') {
                        x = centerX + radius * Math.sin(i * 2 * Math.PI / vertices.length);
                        y = centerY + radius * Math.cos(i * 2 * Math.PI / vertices.length);

                        vertex.position.set(x, y, z);
                    }
                }
            },

            sphereSurface: function (vertices, radius, offsetZ) {

                //        Œ∏ = theta
                //        œÜ = phi
                var n = vertices.length;

                for (var i = 0; i < vertices.length; i++) {
                    var vertex = vertices[i];
                    var phi = Math.acos(-1 + ( 2 * i ) / n);
                    var theta = Math.sqrt(n * Math.PI) * phi;
                    vertex.position.setX(radius * Math.cos(theta) * Math.sin(phi));
                    vertex.position.setY(radius * Math.sin(theta) * Math.sin(phi));
                    vertex.position.setZ(radius * Math.cos(phi) + offsetZ);
                }
            },


            forceDirected: function (vertices, edges, endFunction) {
                var force = d3.layout.force();

                force.charge(-50)
                force.linkDistance(40)

                /*------------------------------------------*/
                /*------------------------------------------*/
                console.time('Force directed preload');

                var d3Vertices = [];
                var d3VerticesMap = {};
                var d3Edges = [];

                //set node and edge arrays for D3
                for (var i = 0, l = vertices.length; i < l; i++) {
                    var vertex = vertices[i];
                    var v = {
                        id: vertex.id,
                        index: i
                    };
                    d3Vertices.push(v);
                    d3VerticesMap[vertex.id] = v;
                }
                force.nodes(d3Vertices);
                for (var i = 0, l = edges.length; i < l; i++) {
                    var edge = edges[i];
                    d3Edges.push({
                        source: d3VerticesMap[edge.source.id],
                        target: d3VerticesMap[edge.target.id]
                    });
                }
                force.links(d3Edges);


                force.on('end', function (o) {
                    console.log(o)
                    endFunction(d3Vertices);
                });

                console.time('D3 Force directed layout');
                force.start();
                var safety = 0;
                while (force.alpha() > 0.025) { // You'll want to try out different, "small" values for this
                    force.tick();
                    if (safety++ > 2000) {
                        break;// Avoids infinite looping in case this solution was a bad idea
                    }
                }
                console.log(safety);
                force.stop();
                console.timeEnd('D3 Force directed layout');


//    force.on('tick', function (o) {
//        endFunction(d3Vertices);
//        console.log(force.alpha())
//        if (force.alpha() < 0.025) {
//            force.stop()
//        }
//    });
//    force.start();

            }
        });
    </script>
</polymer-element>
